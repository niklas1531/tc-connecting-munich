import { Injectable } from '@angular/core';
import { Action, Selector, State, StateContext } from '@ngxs/store';
import {
  combineLatest,
  filter,
  finalize,
  map,
  Observable,
  of,
  switchMap,
  take,
  tap,
} from 'rxjs';
import { autoGeneratedProposalParts, IProposal } from '../interfaces/proposal';
import { ProposalService } from '../services/proposal.service';
import {
  clearSelectedProposal,
  createProposal,
  deleteInCreationProposal,
  generateSummary,
  getProposalById,
  getProposals,
  setProposals,
  setSession,
} from './proposal-overview.actions';

export interface ProposalStateModel {
  isLoading: boolean;
  hasError: boolean;
  proposals: IProposal[];
  filteredProposals: IProposal[];
  selectedFile: FormData;
  selectedFileF: File;
  inCreationProposal: autoGeneratedProposalParts;
  selectedProposal: IProposal | undefined;
  activeSearchSession: string;
}

@State<ProposalStateModel>({
  name: 'ProposalOverview',
  defaults: {
    isLoading: false,
    hasError: false,
    proposals: [],
    filteredProposals: [],
    selectedFile: undefined,
    selectedFileF: undefined,
    inCreationProposal: undefined,
    selectedProposal: undefined,
    activeSearchSession: undefined,
  },
})
@Injectable()
export class ProposalState {
  constructor(private readonly proposalService: ProposalService) {}

  @Selector()
  static isLoading(state: ProposalStateModel): boolean {
    return state.isLoading;
  }

  @Selector()
  static hasError(state: ProposalStateModel): boolean {
    return state.hasError;
  }

  @Selector()
  static proposals(state: ProposalStateModel): IProposal[] {
    return state.proposals;
  }

  @Selector()
  static filteredProposals(state: ProposalStateModel): IProposal[] {
    return state.filteredProposals;
  }

  @Selector()
  static selectedProposal(state: ProposalStateModel): IProposal {
    return state.selectedProposal;
  }

  @Selector()
  static activeSearchSession(state: ProposalStateModel): string {
    return state.activeSearchSession;
  }

  @Selector()
  static inCreationProposal(
    state: ProposalStateModel
  ): autoGeneratedProposalParts {
    return state.inCreationProposal;
  }

  @Selector()
  static selectedFile(state: ProposalStateModel): FormData {
    return state.selectedFile;
  }

  @Action(generateSummary)
  generateSummary(
    context: StateContext<ProposalStateModel>,
    { payload }: generateSummary
  ): Observable<autoGeneratedProposalParts> {
    context.patchState({ isLoading: true });
    return this.proposalService.generateSummary(payload.file).pipe(
      take(1),
      filter((response) => !!response),
      tap((response) =>
        context.patchState({
          inCreationProposal: response,
          selectedFile: payload.file,
          selectedFileF: payload.fileF,
        })
      ),
      finalize(() => void context.patchState({ isLoading: false }))
    );
  }

  @Action(getProposals)
  getProposals(
    context: StateContext<ProposalStateModel>
  ): Observable<IProposal[]> {
    return this.proposalService.getProposals().pipe(
      take(1),
      filter((response) => !!response),
      tap((proposals) =>
        context.patchState({ proposals, filteredProposals: proposals })
      )
    );
  }

  @Action(deleteInCreationProposal)
  deleteInCreationProposal(context: StateContext<ProposalStateModel>) {
    context.patchState({
      inCreationProposal: undefined,
      selectedFile: undefined,
      selectedFileF: undefined,
    });
  }

  @Action(createProposal)
  createProposal(
    context: StateContext<ProposalStateModel>,
    { payload }: createProposal
  ): Observable<IProposal> {
    context.patchState({ isLoading: true });
    return this.proposalService
      .createProposal(payload.proposal, context.getState().selectedFile)
      .pipe(
        take(1),
        switchMap((proposal: IProposal) =>
          combineLatest([
            of(proposal),
            this.proposalService.uploadProposalFile(
              proposal._id,
              context.getState().selectedFile
            ),
            this.proposalService.linkGlossariesToProposal(
              proposal._id,
              payload.glossaries
            ),
          ])
        ),
        map(([proposal, _, __]) => proposal),
        finalize(() => void context.patchState({ isLoading: false }))
      );
  }

  @Action(getProposalById)
  getProposalById(
    context: StateContext<ProposalStateModel>,
    { payload }: getProposalById
  ): Observable<IProposal> {
    return this.proposalService.getProposalById(payload.proposalId).pipe(
      take(1),
      filter((response) => !!response),
      tap((selectedProposal) => context.patchState({ selectedProposal }))
    );
  }

  @Action(clearSelectedProposal)
  clearSelectedProposal(context: StateContext<ProposalStateModel>) {
    context.patchState({ selectedProposal: undefined });
  }

  @Action(setProposals)
  setProposals(
    context: StateContext<ProposalStateModel>,
    { payload }: setProposals
  ): void {
    context.patchState({ proposals: payload.proposals });
  }

  @Action(setSession)
  setSession(
    context: StateContext<ProposalStateModel>,
    { payload }: setSession
  ): void {
    context.patchState({ activeSearchSession: payload.sessionId });
  }
}


